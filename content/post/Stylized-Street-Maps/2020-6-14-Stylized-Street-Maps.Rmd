---
author: "Max Blasdel"
date: "September 29, 2019"
title: "Streets of Humboldt Bay Area"
---

```{r setup, echo=F}
knitr::opts_chunk$set(warning = F, message = F)
```

The following workflow is inspired by some posts I saw on Reddit visualizing the streets of major cities by their suffixes. I decided to do a version for Humboldt. I came up with my own workflow for creating these stylized maps with R.

Data of the streets of Humboldt County was downloaded from the [County Website](https://humboldtgov.org/276/GIS-Data-Download)

## Load Libraries

```{r results='hide', warning=F, message=FALSE}
library(sf) # for spatial manipulation
library(dplyr) # data wrangling
library(ggplot2) # visualization and final graphing
library(mapview) # interactive widget library
```

Find the shapefiles downloaded and unzipped from above link
```{r}
shapes_path <- dir(pattern = ".shp$", # find shp files
                   full.names = T)
```

## Load data

```{r}
roads <-
  read_sf(shapes_path)

# inspect
# head(as.data.frame(roads))
```

There are lots of extra data fields that are not needed here. We inspect to find the `STREETTYPE` column. This step wil take some digging with different datasets.

## Prepare Data

Select only the relevant information for plotting

```{r}
roads <-
  roads %>%
  select(STREETTYPE)
```

Projecting the data into a general lat/long coordinate system.

```{r}
roads <-
  st_transform(roads, crs = 4326) # WGS 84
```

Select a point to center the map around. I played around with this a bit using [Google Earth](https://earth.google.com/web/) and chose a point in Arcata Bay. *You can change the coordinates to deimal in the settings*

```{r}
Eureka <- 
  data.frame(y = 40.828731, 
            x = -124.116183)

Eureka <-
  st_as_sf(Eureka,
         coords = c("x", "y"), 
         crs = 4326) # chose the same coordinate system as above
```

Create a buffer around the chosen point to clip the road data to. The data should really be in a projected coordinate system but this approach still works. The `dist` value here is arc degrees which can be hard to conceptualize. Projecting the data to a UTM coordinate system is probably a better approach.

Check the buffer distance. This was an iterative process to get the `dist` value correct made easier by mapview.
```{r warning=FALSE, message=FALSE}
buf <- st_buffer(Eureka, dist = .08)

  leaflet::leaflet() %>% 
  leaflet::addTiles() %>% 
  leaflet::addPolygons(data = buf)
```
*There will be some warnings about the coordinate system being in lat/long and the distance being in degrees*

Create the buffer and crop the roads layer to inside the desired buffer.

```{r}
buff <-
  st_buffer(Eureka, dist = .08)

roads <-
  st_intersection(roads, buff) 
```

There are lots of suffixes that are not well represented in the data. To keep the legend a reasonable size I'm selecting only the top seven suffixes.

```{r}
top_seven_roads <-
  roads %>%
  as.data.frame() %>% # drop geometry column
  dplyr::count(STREETTYPE) %>%
  arrange(desc(n)) %>% # arrange from most to least
  slice(1:7) %>% # take the top seven
  pull(STREETTYPE)

top_seven_roads
```

### Set all of the other suffixes to "Other"

For this data `NA` was one of the top eight values from the above operation. Notice that `NA` is the R value `NA` while every other value is a character (in quotes). Change `NA` values to "None". Everything else will be "Other".

```{r}
roads <-
  roads %>%
    mutate(STREETTYPE = case_when(is.na(STREETTYPE) ~ "Other",
                                  STREETTYPE %in% top_seven_roads ~ STREETTYPE,
                                  TRUE ~ "Other"))

roads$STREETTYPE %>%
  unique()
```

## Prep data for plotting

Create a vector of colors that is assoicated with each road type and reclassify the characters to factors. This allows the legend to be in the desired order.

I decided to check out the [Studio Ghibli](https://github.com/ewenme/ghibli) color paletts here for fun.
The ghibli color palettes print with the assinged color in the console, which is fun.

```{r}
ghibli::ghibli_palettes$PonyoMedium # going with a relatively varied palette

roads$STREETTYPE <- factor(roads$STREETTYPE,
                           levels = c("RD",
                                      "CT",
                                      "AVE",
                                      "ST",
                                      "DR",
                                      "LN",
                                      "WAY",
                                      "Other"))
```

## Plotting

Plot out the finished product. I put the most time into this part and there are probably other ways to acheive the same results with different ggplot functions. I've added comments to help identify what does what. You may have to change the `plot.title` depending on the output size of the png.

```{r}
ggplot() +
  geom_sf(data = roads,
          aes(colour = STREETTYPE), # color by column value
          show.legend = "point") + # get legend as circles
  theme_void() + # remove default gray background
  theme(legend.position = "bottom",
        text = element_text(size = 20)) + # set all text large. Play with this number based on desired img size
  guides(color = guide_legend(nrow = 2, # have legend all on one line
                              override.aes = (list(size = 5)))) + # change size of point symbols in legend
  scale_color_manual(name = "Street Suffix", # name of legend
                     values = ghibli::ghibli_palettes$PonyoMedium) + # our selected color palette
  ggtitle("Humboldt Bay Area") +
  theme(plot.title = element_text(size = 40)) 
```

## Save output

```{r eval=F}
# ggsave("humStreets.png",
#        width = 12,
#        height = 18,
#        units = "in", # specify units of above height and width
#        dpi = 400) # dots per inch
```

This workflow creates a nice stylized map of street suffixes for Humboldt Bay that can be extended to any area where you have road data.

